{# Sidebar fragment for the Node.js node. Filename must match Node.key (node). #}
{% load static %}
<section id="node-node" class="sidebar-section">

  <header class="sidebar-header">
    <h2 class="sidebar-title">{{ node.label|default:"Node.js" }}</h2>
    {% if node.category %}
      <p class="sidebar-category">Category: {{ node.get_category_display }}</p>
    {% endif %}
  </header>

  <section class="sidebar-block">
    <h3>Overview</h3>
    <p>
      Node.js is a free, open-source JavaScript runtime environment that:
    </p>
    <ul>
        <li>lets you execute JavaScript code outside of a web browser</li>
        <li>enables server-side development with JavaScript</li>
    </ul>
    <p>
        In this section, you will learn the role Node.js plays and the difference between Node.js vs browser runtime environments.
    </p>
  </section>

  <section class="sidebar-block sidebar-facts">
    <div><strong>Estimated time:</strong> 30 minutes</div>
    <div><strong>Difficulty:</strong> Beginner</div>
  </section>

  <section class="sidebar-block">
    <!-- Node.js Introduction -->
    <h2>Node.js</h2>
    <p>
      Since we briefly introduced Node.js as a JavaScript runtime environment for the <strong>server side (back end)</strong>, let's look at some of its characteristics.
    </p>

    <ul>
      <li><strong>Node.js is asynchronous</strong>: it can keep working while waiting on other tasks (eg like reading files or talking to a database)</li>
      <li><strong>Node.js files have <code class="inline-code">.js</code> extension</strong></li>
    
    </ul>

    <!-- Creating and Launching a Server with Node.js -->
    <h3>Creating and Launching a Server with Node.js</h3>
    <p>
      To create a server, follow the steps below: 
    </p>
    <ol>
        <li>First, verify you have Node.js installed by running the following commands, which should return the versions:</li>
        <pre><code>
        node --version 
        npm --version
        </code></pre>
        <li>Create a file with any name but ending with the <code class="inline-code">.js</code> extension (eg <code class="inline-code">firstServer.js</code>) </li>
        <li>Add the following block of code into the file</li>
        <pre><code>
        let http = require('http'); 
        http.createServer(function (req, res) {
            res.writeHead(200, {'Content-Type': 'text/html'});
            res.end('Hello World!');
        }).listen(8080);
        </code></pre>
        <li>
            Node.js files must be initiated in the Command Line interface. Navigate to the folder that contains the file "<code class="inline-code">firstServer.js</code>"
        --> go to the CLI --> initiate Node.js file.</li>
        <pre><code>
        node firstServer.js
        </code></pre>
        <li>Your server has now been initiated. </li>
    </ol>
    <p><strong>Here's a summary of what happened: </strong></p>
    <ol>
        <li>Node.js loades the built-in <code class="inline-code">http</code> module</li>
        <li>This module allows us to create a server that listens for HTTP requests on your port 8080</li>
        <li>Each time a client visits your server, Node.js calls your callback function</li>
        <li>The server sends back an HTML response with "Hello World!", according to the above code block we wrote</li>
        <li>Browser displays the message back to the client</li>
    </ol>
    
    <!-- Browser -->
    <h2>Browsers</h2>
    <p>
      In addition to Node.js, another JavaScript environment is browser for the <strong>client side (front end)</strong>. 
      It includes: 
    </p>
    <ul>
        <li>JavaScript engine to execute JS code</li>
        <li>Browser-specific APIs such as:</li>
        <ul>
            <li><code class="inline-code">window</code> - browser window/tab</li>
            <li><code class="inline-code">document</code> - HTML page (DOM)</li>
            <li><code class="inline-code">fetch()</code> - makes HTTP request</li>
            <li><code class="inline-code">localStorage</code> - stores data locally</li>
        </ul>
    </ul>

    <!-- Node.js vs Browser -->
    <h2>Node.js vs Browsers</h2>
    <p>
        Both Node.js and browsers are runtime environments for executive JavaScript. They do differ, and can affect how you write your unit tests 
        for the front end. 
    </p>
    <p>
        Running JavaScript in <strong>Node.js</strong> means executing code on the <strong>server side</strong> (back end), outside of a browser. 
        Node provides access to backend tools like the filesystem, network, and OS through modules such as fs and http. 
    </p>
    <p>
        Running JavaScript in a <strong>browser</strong> means executing code on the <strong>client side</strong> (front end), inside a web page. The
        browser provides APIs for the DOM, <code class="inline-code">window</code>, and user interaction, but cannot access your computer's files or 
        systems directly. 
    </p>
    <p>Below is a table that summarizes the main difference between the two JavaScript environments:</p>
    <img 
      src="{%static 'roadmap/img/node-vs-browser.png' %}"
      alt="Node.js vs Browser Comparison Table"
    >
    
    <!-- Designing Unit Tests for browser dependent tests -->
    <h2>Designing Unit Tests and Deciding to user Node.js vs Browser Environment</h2>
    <p>
      As an intern, some of your first few tickets will be to design unit tests for front end code for Laser.
      Some of these functions may appear to require a browser environment (eg <code class="inline-code">getCookie()</code>)
    </p>
    <pre><code>
    
    /**
    * Returns the value of a cookie based on the cookie name.
    * From https://docs.djangoproject.com/en/3.2/ref/csrf/#ajax.
    * @param {string} name - Name of cookie.
    * @returns {*}
    */
    export function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== "") {
            const cookies = document.cookie.split(";");
            for (let i = 0; i &lt; cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === name + "=") {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    </code></pre>
    <p>
        This function expects to be run in a browser, where <code class="inline-code">document.cookie</code> is a real browser API that stores 
        all cookies for the current webpage.
    </p>
    <p>
        If we used <strong>JavaScript-based simulation of a web browser's DOM (JSDOM)</strong> in Jest to create a fake <code class="inline-code">document</code> 
        to simulate the browser, this would have been straightforward. However, with the unit tests, they're usually written in one giant file with 
        multiple other unit tests that do NOT require JSDOM. Thus, we cannot simply import this module as it will break the other tests previous 
        interns have worked so hard to implement. So instead, we have to get creative. 
    </p>
    <p>
        An alternative solution is to mock the exact data we need to test the <code class="inline-code">getCookie()</code> function. In essence, 
        create a fake <code class="inline-code">document</code> object and attach it to the global scope in Node.js. To implement this, follow
        the steps below
    </p>
    <h3>Manually Mocking Fake Document Object for non-JSDOM Tests</h3>
    <ol>
        <li>In your <code class="inline-code">describe("getCooke()"...)</code>function, create a variable <code class="inline-code">originalDocument</code>
            that is assigned whatever <code class="inline-code">global.document</code>was before. In Jest where JSDOM was never imported, 
            <code class="inline-code">global.document</code> will most likely be <code class="inline-code">undefined.</code>
        </li>
        <pre><code>
        describe("getCookie()", () => {
            const originalDocument = global.document; 
        });
        </code></pre>
        <li>
            Create an <code class="inline-code">afterEach()</code> function that resets the <code class="inline-code">global.document</code> back to 
            <code class="inline-code">originalDocument</code>. Since <code class="inline-code">originalDocument</code> was technically 
            <code class="inline-code">undefined</code>, <code class="inline-code">afterEach()</code> is essentially resetting the environment back to 
            <code class="inline-code">undefined</code> after each test. This ensures that previous tests will not impact the mock data we are feeding 
            future tests. This may seem pointless right now, but it is best practice to prevent opportunities of mix ups later on.
        </li>
        <pre><code>
        afterEach(() => {
            global.document = originalDocument;
        });
        </code></pre>
        <li>
            In your tests, reset the <code class="inline-code">global.document</code> to take on the mock parameters you need to test your function. In our example, 
            we are trying to test <code class="inline-code">getCookie()</code> function, which takes in a cookie name as a parameter. Thus, we must mock a fake cookie 
            name to feed into our function. By doing so, you are essentially telling Node to pretend that there is a <code class="inline-code">document</code> object 
            with a <code class="inline-code">cookie</code> property equal to whatever you set it as. 
        </li>
        <pre><code>
        test("returns cookie value for valid cookie name that exists in the cookie document", 
            () => {
            global.document = {
                cookie: "theme=dark; sessionid=abc"
            };
            const name = "theme";
            expect(getCookie(name)).toBe("dark");
        });
        </code></pre>
        <li>
            Since you implemented the <code class="inline-code">afterEach()</code> function, after this test is done running, <code class="inline-code">global.document</code>
            will be reset to <code class="inline-code">undefined</code>, thus preventing this previous test from impacting the mock <code class="inline-code">document</code>
            for future tests.
        </li>
        <li>
            Add more tests to provide sufficient coverage.
        </li>
    </ol>
    <p>
        This is what your entire test suite should look like after you've implemented these steps:
    </p>
    <pre><code>
    describe("getCookie()", () => {
        const originalDocument = global.document;

        afterEach(() => {
            global.document = originalDocument;
        });

        test("returns cookie value for valid cookie name that exists in the cookie document", 
        () => {
            global.document = {
                cookie: "theme=dark; sessionid=abc";
            };
            const name = "theme";
            expect(getCookie(name)).toBe("dark");
        });
    });
    </code></pre>

</section>

  <section class="sidebar-block">
    <h3>Check your understanding</h3>
    <!-- Question 1 -->
    <details>
      <summary>What is the old and modern IP formats?</summary>
      <ul>
        <li>IPv4 (old)</li>
        <li>IPv6 (modern)</li>
      </ul>
    </details>
    <!-- Question 2 -->
    <details>
      <summary>What are the two types of IP addresses?</summary>
        <ul>
          <li>Public IP - used to identify devices on a public network (eg Internet)</li>
          <li>Private IP - used to identify devices on the same private, local network (eg your home network)</li>
        </ul>
    </details>
    <!-- Question 3 -->
    <details>
      <summary>What is a MAC Address and what is its purpose? </summary>
        <ul>
          <li>MAC Address - is essentially your device's physical address on a local network</li>
          <li>It is used to deliver data from a device to another device on the same network</li>
        </ul>
    </details>
    <!-- Question 4 -->
    <details>
      <summary>How is information sent from your laptop to the internet?</summary>
      <ol>
        <li>Your laptop uses ARP broadcast to locate the router in its local network with a corresponding private IP</li>
        <li>The router responds to the laptop's broadcast by directly sending its MAC Address</li>
        <li>Your laptop uses this MAC Address to send data to the router</li>
        <li>The router then runs this data through NAT to assign its public IP to replace the laptop's private IP </li>
        <li>The router sends data to the desintation server on the Internet</li>
      </ol>
    </details>
    <!-- Question 5 -->
    <details>
      <summary>Internet servers can access your laptop's private IP address directly. True or False?</summary>
      <ul>
        <li>No, your laptop will present data with your router's public IP</li>
      </ul>
    </details>
  </section>

  <section class="sidebar-block">
    <h3>Resources</h3>
    <ul>
      {% if node.url %}
        <li><a href="{{ node.url }}" target="_blank" rel="noopener">Primary learning resource</a></li>
      {% endif %}
      <li><a href="https://www.w3schools.com/nodejs/default.asp" target="_blank">Node.js</a></li>
      <li><a href="https://www.w3schools.com/nodejs/nodejs_vs_browser.asp" target="_blank">Node.js vs Browser</a></li>
    </ul>
  </section>

</section>
